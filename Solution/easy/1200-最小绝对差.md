## 题目描述
给定一个整数数组`arr`，其中每个元素都各不相同，按照升序顺序返回所有具有最小绝对差的元素对。  
每对元素对`[a , b]`如下：  
<!-- * `a`和`b`都是数组`arr`中的元素
* `a < b`
* `b - a`等于数组中任意两个元素的最小绝对差 -->
 <ul style="padding-left: 1.2em; margin: 0;">
  <li style="line-height: 1.8;">
    <code>a</code> 和 <code>b</code> 都是数组 <code>arr</code> 中的元素
  </li>
  <li style="line-height: 1.8;">
    <code>a &lt; b</code>
  </li>
  <li style="line-height: 1.8;">
    <code>b - a</code> 等于数组中任意两个元素的最小绝对差
  </li>
</ul>
<br>

## 题解
显然，将`arr`排序后，最小绝对差只能来自相邻元素。  
设置最小绝对差为`mad = INT_MAX`,遍历`arr`中的相邻元素： 
  <li style="line-height: 1.8;">
    如果当前相邻元素差小于<code>mad</code>，则更新<code>mad</code>为当前相邻元素差，清空<code>res</code>并将该元素对添加到答案中。
  </li>
  <li style="line-height: 1.8;">
    如果当前相邻元素差等于<code>mad</code>,则将该元素对添加到答案中。
  </li>
<br>

```cpp
class Solution {
public:
    vector<vector<int>> minimumAbsDifference(vector<int>& arr) {
        vector<vector<int>> res;
        sort(arr.begin(),arr.end());
        int mad = INT_MAX;
        int n = arr.size();
        for(int i = 0;i < n - 1;i ++){
            if(arr[i + 1] - arr[i] < mad){
                mad = arr[i + 1] - arr[i];
                res.clear();
                res.push_back({arr[i],arr[i + 1]});
            }else if(arr[i + 1] - arr[i] == mad){
                res.push_back({arr[i],arr[i + 1]});
            }
        }
        return res;
    }
};
```
<br>

## 复杂度分析
<ul style="padding-left: 1.2em;margin: 0;">
  <li style="line-height:1.8;">
  时间复杂度：<code>O(nlogn)</code>,其中<code>n</code>是数组长度，排序时间为<code>O(nlogn)</code>,而遍历数组时间为<code>O(n)</code>,瓶颈在排序上。
  </li>
  <li style="line-height: 1.8;">
  空间复杂度：<code>O(1)</code>,不需要额外空间。